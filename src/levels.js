export const gameLevels = [
  {//level 1
    background: [
      "ttwwwtttt",
      "ttwgwtttt",
      "ttwgwwwwt",
      "wwwggggwt",
      "wggggwwwt",
      "wwwwgwttt",
      "tttwgwttt",
      "tttwwwttt",
      "ttttttttt"
    ],
    marks: [[3,1], [1,4], [6,3], [4,6]],
    boxes: [[3,4], [3,3], [5,3], [4,5]],
    player: [4,4]
  },
  {//level 2
    background: [
      "wwwwwtttt",
      "wgggwtttt",
      "wgggwtwww",
      "wgggwtwgw",
      "wwwgwwwgw",
      "twwgggggw",
      "twgggwggw",
      "twgggwwww",
      "twwwwwttt"
    ],
    marks: [[7,3], [7,4], [7,5]],
    boxes: [[2,2], [2,3], [3,3]],
    player: [3,2]
  },
  {//level 3
    background: [
      "twwwwtttt",
      "wwggwtttt",
      "wgggwtttt",
      "wwggwwttt",
      "wwgggwttt",
      "wggggwttt",
      "wggggwttt",
      "wwwwwwttt",
      "ttttttttt"
    ],
    marks: [[1,5], [1,6], [2,6], [3,6], [4,6]],
    boxes: [[3,2], [2,3], [3,4], [2,5], [3,6]],
    player: [2,2]
  },
  {//level 4
    background: [
      "twwwwtttt",
      "twggwwwtt",
      "twggggwwt",
      "wwwgwgwwt",
      "wgwgwggwt",
      "wggggwgwt",
      "wggggggwt",
      "wwwwwwwwt",
      "ttttttttt"
    ],
    marks: [[1,4], [1,5], [1,6]],
    boxes: [[3,2], [2,5], [5,6]],
    player: [2,1]
  },
  {//level 5
    background: [
      "ttwwwwwwt",
      "ttwggggwt",
      "wwwggggwt",
      "wggggggwt",
      "wgggggwwt",
      "wwwwggwtt",
      "tttwwwwtt",
      "ttttttttt",
      "ttttttttt"
    ],
    marks: [[3,4], [4,4], [5,4], [4,3], [5,3]],
    boxes: [[2,4], [3,3], [3,2], [4,2], [5,2]],
    player: [1,3]
  },
  {//level 6
    background: [
      "ttwwwwwtt",
      "wwwgggwtt",
      "wgggggwwt",
      "wggggggwt",
      "wwwggggwt",
      "ttwgggwwt",
      "ttwwwwwtt",
      "ttttttttt",
      "ttttttttt"
    ],
    marks: [[3,3], [4,2], [5,3], [4, 4]],
    boxes: [[3,2], [4,3], [5,4], [4, 4]],
    player: [5,1]
  },
  {//level 7
    background: [
      "ttwwwwttt",
      "ttwggwttt",
      "twwggwwtt",
      "twggggwtt",
      "wwggggwwt",
      "wggwgggwt",
      "wggggggwt",
      "wwwwwwwwt",
      "ttttttttt"
    ],
    marks: [[3,1], [4,1], [4,2], [5,3]],
    boxes: [[4,3], [3,4], [4,5], [5,5]],
    player: [3,6]
  },
  {//level 8
    background: [
      "wwwwwwwwt",
      "wggwgggwt",
      "wggggggwt",
      "wgggggwwt",
      "wggggggwt",
      "wggwgggwt",
      "wwwwwwwwt",
      "ttttttttt",
      "ttttttttt"
    ],
    marks: [[3,2], [3,3], [3,4], [4,2], [4,3], [4,4]],
    boxes: [[2,2], [2,3], [2,4], [5,2], [4,3], [5,4]],
    player: [1,2]
  },
  {//level 9
    background: [
      "wwwwwwttt",
      "wggggwttt",
      "wggggwwtt",
      "wggwggwww",
      "wwggggggw",
      "twggggggw",
      "twwwwwwww",
      "ttttttttt",
      "ttttttttt"
    ],
    marks: [[4,3], [4,4], [5,3], [5,4]],
    boxes: [[2,2], [3,2], [4,2], [6,4]],
    player: [3,5]
  },
  {//level 10
    background: [
      "wwwwwwwtt",
      "wgggggwtt",
      "wggwggwtt",
      "wgggggwtt",
      "wgggggwtt",
      "wgggggwtt",
      "wggwggwtt",
      "wwwwwwwtt",
      "ttttttttt"
    ],
    marks: [[1,1], [1,2], [2,1], [2,2], [4,1], [4,2], [5,1], [5,2]],
    boxes: [[3,1], [2,3], [3,3], [4,3], [2,5], [3,5], [4,5], [3,4]],
    player: [4,6]
  },
  {//level 11
    background: [
      "twwwwwttt",
      "twgggwwwt",
      "wwgwgggwt",
      "wggggggwt",
      "wgggggwwt",
      "wwwgwgwtt",
      "ttwgggwtt",
      "ttwwwwwtt",
      "ttttttttt"
    ],
    marks: [[2,3], [3,3], [5,3], [5,5]],
    boxes: [[2,3], [3,4], [4,4], [4,2]],
    player: [3,1]
  },
  {//level 12
    background: [
      "wwwwwwttt",
      "wggggwttt",
      "wggggwttt",
      "wwgggwttt",
      "wgggwwttt",
      "wgggwtttt",
      "wgggwtttt",
      "wgggwtttt",
      "wwwwwtttt"
    ],
    marks: [[2,3], [2,4], [2,5], [2,6], [2,7]],
    boxes: [[2,2], [2,3], [2,4], [2,5], [2,6]],
    player: [4,2]
  },
  {//level 13
    background: [
      "ttwwwwttt",
      "ttwggwttt",
      "wwwggwwtt",
      "wgggggwtt",
      "wgggggwtt",
      "wggggwwtt",
      "wwwggwttt",
      "ttwgwwttt",
      "ttwwwtttt"
    ],
    marks: [[3,3], [3,4], [3,5], [3,6], [3,7]],
    boxes: [[3,2], [3,3], [3,4], [3,5], [3,6]],
    player: [5,3]
  },
  {//level 14
    background: [
      "wwwwwtttt",
      "wgggwwwww",
      "wgwgwgggw",
      "wgggggggw",
      "wggwgwgww",
      "wggggggwt",
      "wggggwwwt",
      "wwwwwwttt",
      "ttttttttt"
    ],
    marks: [[1,4], [2,4], [1,5], [1,6], [2,6]],
    boxes: [[1,2], [3,5], [3,6], [6,3], [6,4]],
    player: [3,3]
  },
  {//level 15
    background: [
      "twwwwwwtt",
      "twggggwwt",
      "wwgwwggwt",
      "wggggggwt",
      "wggwgggwt",
      "wggggwwwt",
      "wwwwwwttt",
      "ttttttttt",
      "ttttttttt"
    ],
    marks: [[2,2], [2,3], [3,3]],
    boxes: [[4,3], [4,4], [5,2]],
    player: [3,5]
  }
];

let gameObjects = []; // save to local storage
let gameLastMoves = []; // save to local storage

class Block {
  constructor(xb, yb, unit) {
    this.x = xb * 50;
    this.y = yb * 50;
    this.unit = unit;
  }

  draw(canvas, images) {
    //boy image needs custom coords
    if(this.unit === "boy") {
      canvas.current.getContext("2d").drawImage(images[this.unit], this.x - 5, this.y - 20, 60, 80);
    }else {
      canvas.current.getContext("2d").drawImage(images[this.unit], this.x, this.y, 50, 50);
    }
  }

  move(direction, setMoves, setPushes) {
    const coords = {"left": [-50,0], "right": [50,0], "up": [0,-50], "down": [0,50]};
    direction = direction.slice(5).toLowerCase(); // extract direction from event.key
    handleBlockMove.call(this, direction, coords[direction], setMoves, setPushes);
    saveData("gameObjects", gameObjects);
    saveData("gameLastMoves", gameLastMoves);
  }

  //return the siblings from the four sides left, right, up and down
  getSiblings() {
    const self = this, siblings = {left: 0, right: 0, up: 0, down: 0};
    gameObjects.forEach(unit => {
      if(self.x - unit.x === 50 && self.y - unit.y === 0) {
        siblings.left = unit;
      }else if(self.x - unit.x === -50 && self.y - unit.y === 0) {
        siblings.right = unit;
      }else if(self.y - unit.y === 50 && self.x - unit.x === 0) {
        siblings.up = unit;
      }else if(self.y - unit.y === -50 && self.x - unit.x === 0) {
        siblings.down = unit;
      }
    });
    return siblings;
  }
}

function handleLastMove(lastMove) {
  // store up to 100 previous moves
  if(gameLastMoves.length === 100) {
    gameLastMoves.shift();
  }
  gameLastMoves.push(lastMove);
}

function handleBlockMove(direction, moveCoords, setMoves, setPushes) {
  const nextSibling = this.getSiblings()[direction];
  
  if(nextSibling === 0) {
    this.x += moveCoords[0];
    this.y += moveCoords[1];
    setMoves(prev => saveData("moves", prev + 1));
    handleLastMove (
      {
        coords: {x: moveCoords[0], y: moveCoords[1]},
        box: null
      }
    );
  }else if(nextSibling.unit !== "wall") {
    const secondNextSibling = nextSibling.getSiblings()[direction];
    if(this.unit === "boy" && (nextSibling.unit === "box" || nextSibling.unit === "goldenBox") && secondNextSibling.unit !== "box" && secondNextSibling.unit !== "goldenBox" && secondNextSibling.unit !== "wall") {
      nextSibling.x += moveCoords[0];
      nextSibling.y += moveCoords[1];
      setPushes(prev => saveData("pushes", prev + 1));
      this.x += moveCoords[0];
      this.y += moveCoords[1];
      setMoves(prev => saveData("moves", prev + 1));
      handleLastMove(
        {
          coords: {x: moveCoords[0], y: moveCoords[1]},
          box: nextSibling,
          boxIndex: gameObjects.indexOf(nextSibling)
        }
      );
    }
  }
}

function drawMarks(canvas, level, images) {
  const marksCount = gameLevels[level - 1].marks.length;
  for(var i = 0;i < marksCount;i++) {
    let marks = gameLevels[level - 1].marks[i];
    canvas.current.getContext("2d").drawImage(images.mark, marks[0] * 50, marks[1] * 50, 50, 50);
  }
}

export function drawBackground(canvas, level, images) {
  for(var i = 0;i < 9;i++) {
    for(var j = 0;j < 9;j++) {
      let imageSymbol = gameLevels[level - 1].background[i][j];
      let currentImage = {t: images.tree, w: images.wall, g: images.grass}[imageSymbol];
      canvas.current.getContext("2d").drawImage(currentImage, j * 50, i * 50, 50, 50);
    }
  }
  drawMarks(canvas, level, images);
}

function createWallObjects(level, images) {
  for(var i = 0;i < 9;i++) {
    for(var j = 0;j < 9;j++) {
      if(gameLevels[level - 1].background[i][j] === 'w') {
        gameObjects.push(new Block(j, i, "wall"));
      }
    }
  }
}

function createBoxObjects(level, images) {
  for(var i = 0;i < gameLevels[level - 1].boxes.length;i++) {
    const box = gameLevels[level - 1].boxes[i];
    gameObjects.push(new Block(box[0], box[1], "box"));
  }
}

export function handelMarkedBoxes(level, increaseReachedLevel, setIsWinner) {
  let markedBoxes = 0;
  gameObjects.forEach(function(obj) {
    if(obj.unit === "box" || obj.unit === "goldenBox") {
      obj.unit = "box";
      gameLevels[level - 1].marks.forEach(function(mark) {
        if(mark[0] === obj.x / 50 && mark[1] === obj.y / 50) {
          obj.unit = "goldenBox";
          markedBoxes++;
        }
      });
    }
  });


  if(markedBoxes === gameLevels[level - 1].marks.length) {
    document.body.onkeyup = null;
    setTimeout(function() {
      increaseReachedLevel();
    }, 500);
  }
}

function recreateSavedObjects() {
  let gameObjects = getSavedData("gameObjects");
  return gameObjects.map(({x, y, unit}) => new Block(x / 50, y / 50, unit));
}

export function createLevelObjects(level, images) {
  gameLastMoves = getSavedData("gameLastMoves");
  gameObjects = recreateSavedObjects();
  console.log(gameLastMoves, gameObjects);
  const player = gameLevels[level - 1].player;
  if(gameObjects.length === 0) {
    gameObjects.push(new Block(player[0], player[1], "boy"));
    createWallObjects(level, images);
    createBoxObjects(level, images);
  }
}

export function drawForeground(canvas, images) {
  canvas.current.getContext("2d").clearRect(0, 0, 450, 450);
  gameObjects.forEach(function(unit) {
    unit.draw(canvas, images);
  });
}

export function resetSavedData() {
  // Initialize a template for saving the data, this way
  // I don't need to check if something is missing and then
  // give it an initial value, that's too much unnecessary work
  localStorage.sokoban = JSON.stringify({
    lastMoveDisabled: true,
    moves: 0,
    pushes: 0,
    gameObjects: [],
    gameLastMoves: [],
    reachedLevel: 1,
    level: 1
  });
}

export function saveData(name, value) {
  if(!localStorage.sokoban) {
    resetSavedData();
  }
  let sokoban = JSON.parse(localStorage.sokoban);
  sokoban[name] = value;
  localStorage.sokoban = JSON.stringify(sokoban);
  return value; // so it can be used inside a state setter
}

export function getSavedData(name) {
  if(!localStorage.sokoban) {
    resetSavedData();
  }
  return JSON.parse(localStorage.sokoban)[name];
}

export function undoLastMove(setMoves, setPushes, setLastMoveDisabled) {
  if(gameLastMoves.length === 0) {
    return;
  }
  let gameLastMove = gameLastMoves.pop();
  const player = gameObjects[0];
  player.x -= gameLastMove.coords.x;
  player.y -= gameLastMove.coords.y;
  setMoves(prev => saveData("moves", prev - 1));
  if(gameLastMove.box) {
    let box = gameObjects[gameLastMove.boxIndex];
    box.x -= gameLastMove.coords.x;
    box.y -= gameLastMove.coords.y;
    setPushes(prev => saveData("pushes", prev - 1));
  }
  if(gameLastMoves.length === 0) {
    setLastMoveDisabled(saveData("lastMoveDisabled", true));
  }
  saveData("gameObjects", gameObjects);
}

export function movePlayer(keyCode, setMoves, setPushes) {
  const player = gameObjects[0];
  player.move(keyCode, setMoves, setPushes);
}